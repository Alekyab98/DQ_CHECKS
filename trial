CREATE OR REPLACE PROCEDURE aid_nwperf_aether_core_tbls.aether_amf_performance_sptest(process_ts STRING,trans_ts STRING,window_hour int64,window_interval int64)
options(strict_mode=False)

BEGIN
 
merge into `vz-it-np-gudv-dev-dtwndo-0.aid_nwperf_aether_core_tbls.aether_amf_performance_counttest` tgt
using (
    SELECT
      event_time AS event_time,
      "ericsson" AS vendor,
      fqdn,
      KEY AS metric_name,
      safe_cast(increase_value AS bignumeric) AS metric_increase_value,
      safe_cast(sum_value AS bignumeric) AS metric_sum_value,
      trans_dt,
      datetime(process_ts) AS schedule_time,
      current_timestamp AS updated_timestamp,
      -- Calculate datapoints_count once
    FROM (
      WITH event_timestamps AS (
        SELECT DISTINCT DATETIME_TRUNC(timestamp(`timestamp`), HOUR) AS trans_hr 
        FROM `vz-it-pr-i37v-ndldo-0.vzn_ndl_aether_core_tbls_rd_v.ericsson_cnf_amf_raw_v1`
        WHERE DATETIME_TRUNC(timestamp(insert_date_utc), HOUR) IN 
              UNNEST(GENERATE_TIMESTAMP_ARRAY(TIMESTAMP_SUB(DATETIME_TRUNC(timestamp(trans_ts), HOUR), INTERVAL window_interval - 1 HOUR), DATETIME_TRUNC(timestamp(trans_ts), HOUR), INTERVAL window_hour HOUR))
        AND trans_dt IS NOT NULL
      ),
      base_data AS (
        SELECT *,
               MD5(labels) AS checksum
        FROM (
          SELECT DISTINCT
            TIMESTAMP_SECONDS(CAST(FLOOR(UNIX_SECONDS(`timestamp`) / (window_hour * 60 * 60)) * (window_hour * 60 * 60) AS INT64)) AS event_time,
            fqdn,
            TO_JSON_STRING(JSON_REMOVE(SAFE.PARSE_JSON(labels), '$.__name__', '$.jobid', '$.localdn')) AS labels,
            JSON_VALUE(labels, '$.instance') AS instance,
            LOWER(name) AS KEY,
            SAFE_CAST(NULLIF(value, 'NaN') AS FLOAT64) AS value,
            DATE(`timestamp`) AS trans_dt,
          FROM `vz-it-pr-i37v-ndldo-0.vzn_ndl_aether_core_tbls_rd_v.ericsson_cnf_amf_raw_v1`
          WHERE DATETIME_TRUNC(timestamp(`timestamp`), HOUR) IN (SELECT trans_hr FROM event_timestamps)
            AND insert_date_utc > (SELECT MIN(trans_hr) FROM event_timestamps)
            AND trans_dt IN (SELECT DATE(trans_hr) FROM event_timestamps)
            AND trans_dt IS NOT NULL
        )
      ),


      window_data AS (
        SELECT *,
               IF(value < prev_value, 1, 0) AS has_reset
        FROM (
          SELECT
            trans_dt,
            event_time,
            fqdn,
            labels,
            checksum,
            instance,
            KEY,
            value,
            `timestamp`,
           
            SAFE_CAST(LAG(value) OVER (PARTITION BY fqdn, checksum, instance, KEY, DATETIME_TRUNC(timestamp, HOUR) ORDER BY `timestamp`) AS FLOAT64) AS prev_value
          FROM base_data
        )
        
      ),

     count_cal as (
      select *, count(value) OVER (PARTITION BY fqdn, checksum, instance, KEY, DATETIME_TRUNC(timestamp,HOUR) ORDER BY `timestamp`) as 
      datapoints_count,
      FROM window_data

     ),
      reset_adjusted AS (
        SELECT
          event_time,
          fqdn,
          instance,
          trans_dt,
          MAX(labels) AS labels,
          checksum,
          KEY,
          SUM(value) AS sum_value,
          SUM(CASE
              WHEN prev_value IS NULL THEN 0
              WHEN has_reset = 1 THEN value
              ELSE value - IFNULL(prev_value, 0)
          END) AS increase_value
        FROM count_cal
        GROUP BY trans_dt, event_time, instance, fqdn, checksum, KEY
      )
    SELECT
      event_time,
      fqdn,
      trans_dt,
      KEY,
      SUM(increase_value) AS increase_value,
      SUM(sum_value) AS sum_value,
      COUNT(*) OVER (PARTITION BY trans_dt, event_time, fqdn, KEY) AS datapoints_count  -- Calculate datapoints_count
    FROM reset_adjusted
    GROUP BY trans_dt, event_time, fqdn, KEY
    ORDER BY trans_dt, event_time, fqdn, KEY)
  ) src
  ON tgt.trans_dt = src.trans_dt
    AND tgt.event_time = src.event_time
    AND tgt.fqdn = src.fqdn
    AND tgt.metric_name = src.metric_name
    AND tgt.vendor = src.vendor
    AND tgt.trans_dt IS NOT NULL
  WHEN MATCHED THEN
    UPDATE SET
      tgt.metric_increase_value = src.metric_increase_value,
      tgt.metric_sum_value = src.metric_sum_value,
      tgt.schedule_time = src.schedule_time,
      tgt.updated_timestamp = src.updated_timestamp,
      tgt.datapoints_count = src.datapoints_count  -- Update datapoints_count with the calculated value
  WHEN NOT MATCHED THEN
    INSERT (
      event_time,
      vendor,
      fqdn,
      metric_name,
      metric_increase_value,
      metric_sum_value,
      trans_dt,
      schedule_time,
      updated_timestamp,
      datapoints_count  -- Insert datapoints_count
    )
    VALUES (
      src.event_time,
      src.vendor,
      src.fqdn,
      src.metric_name,
      src.metric_increase_value,
      src.metric_sum_value,
      src.trans_dt,
      src.schedule_time,
      src.updated_timestamp,
      src.datapoints_count  -- Insert the calculated datapoints_count
    );
END;
